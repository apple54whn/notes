# 指令

## 插值

### 文本—Mustache 语法

Mustache 语法 (双大括号) 

```html
<span>Message: {{ msg }}</span>
```

Mustache 标签将会被替代为对应数据对象上 `msg` 属性的值。无论何时，绑定的数据对象上 `msg` 属性发生了改变，插值处的内容都会更新。

**Mustache 中存放的是变量对象，即可以放方法（需带括号）**，若**用引号引用则视作字符串**不再解析。



### 文本—v-once

只渲染元素和组件**一次**。随后的重新渲染，**元素/组件及其所有的子节点**将被视为静态内容并跳过。这可以用于优化更新性能。通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定

```html
<!-- 单个元素 -->
<span v-once>This will never change: {{msg}}</span>
<!-- 有子元素 -->
<div v-once>
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>
<!-- 组件 -->
<my-component v-once :comment="msg"></my-component>
<!-- `v-for` 指令-->
<ul>
  <li v-for="i in list" v-once>{{i}}</li>
</ul>
```



### 文本—v-text

作用和 Mustache 相似，更新元素的 `textContent`。如果要更新部分的 `textContent` ，需要使用 `{{ Mustache }}` 插值。但是**会覆盖该标签的内容**！不灵活，一般使用较少！



### 原始 HTML—v-html

**双大括号会将数据解释为普通文本**，而非 HTML 代码。为了输出真正的 HTML，你需要使用 `v-html`[ 指令](https://cn.vuejs.org/v2/api/#v-html)：

```html
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

这个 `span` 的内容将会被替换成为属性值 `rawHtml`，直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 `v-html` 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。



### v-pre

如`<pre>`，**跳过这个元素和它的子元素**的**编译过程**。可用来**显示原始 Mustache 标签**。跳过大量没有指令的节点会加快编译。

```html
<span v-pre>{{ this will not be compiled }}</span>
```



### v-cloak

::: tip cloak

披风; 斗篷; 大衣; 氅

:::

这个指令**保持在元素上直到关联实例结束编译**，可以据此来实现判断。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。基本也不会使用，和虚拟DOM有关，没懂。

```css
[v-cloak] {
  display: none;
}
```

```html
<div v-cloak>
  {{ message }}
</div>
```

不会显示，直到编译结束。





## Class 与 Style 绑定

### 使用`:` 或 `v-bind`

-   **预期**：`any (with argument) | Object (without argument)`

-   **参数**：`attrOrProp (optional)`。大致理解 attr 为 HTML 属性（可自定义），prop 为 JS 属性

-   **修饰符**：

    -   `.prop` - 作为一个 DOM property 绑定而不是作为 attribute 绑定。([差别在哪里？](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))
    -   `.camel` - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)。见Style绑定
    -   `.sync` (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 `v-on` 侦听器。

-   **用法**：

    动态地绑定一个或多个特性，或一个组件 prop 到表达式。

    在绑定 `class` 或 `style` 特性时，**支持其它类型的值，如数组或对象**。可以通过下面的教程链接查看详情。

    在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。

    没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。

-   **示例**：

    ```html
    <!-- 绑定一个属性 -->
    <img v-bind:src="imageSrc">
    <!-- 缩写 -->
    <img :src="imageSrc">
    
    <!-- 动态特性名 (2.6.0+) -->
    <button v-bind:[key]="value"></button>
    <!-- 动态特性名缩写 (2.6.0+) -->
    <button :[key]="value"></button>
    
    <!-- 绑定一个有属性的对象 -->
    <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
    
    <!-- 通过 prop 修饰符绑定 DOM 属性 -->
    <div v-bind:text-content.prop="text"></div>
    
    <!-- prop 绑定。“prop”必须在 my-component 中声明。-->
    <my-component :prop="someThing"></my-component>
    
    <!-- 通过 $props 将父组件的 props 一起传给子组件 -->
    <child-component v-bind="$props"></child-component>
    
    <!-- XLink -->
    <svg><a :xlink:special="foo"></a></svg>
    ```

    `.camel` 修饰符允许在使用 DOM 模板时将 `v-bind` 属性名称驼峰化，例如 SVG 的 `viewBox` 属性：

    ```html
    <svg :view-box.camel="viewBox"></svg>
    ```

    在使用字符串模板或通过 `vue-loader`/`vueify` 编译时，无需使用 `.camel`。



### 绑定 HTML Class

*   绑定**对象**（使用很多）

    根据**值**的`truthy`（真值，除 `false`、`0`、`""`、`null`、`undefined` 和 `NaN` 以外）来**决定键的渲染**。

    会和**普通的 class 共存**。

    若过于**复杂**，可放入 methods 或 compute 中。**method必须加括号来调用**该方法（与@不一样！）；**compute 属性不用加括号**。**方法中只要返回对象或数组**。

    ```html
    <div class="my-class" :class="{ red: isRed, blod: isBlod }"></div>
    ```

    ```html
    <div class="my-class" :class="MyClassMethod()"></div>
    <div class="my-class" :class="MyClassCompute"></div>
    ```

    上述事例中若 isRed 为 false，isBlod 为 true，则渲染后的 class 只有 isBlod。常用于 toggle 切换 class，取反即可。

*   绑定**数组**（使用较少）细节同绑定对象

    ```html
    <!-- 若classA添加了引号如：'classA'则和普通class属性一样，没有响应式 -->
    <div :class="[classA, classB]"></div>
    ```

    当有多个条件 class 时，可以在数组中包含对象

    ```html
    <div :class="[classA, { classB: isB, classC: isC }]">
    ```

    当 isB 和 isC 都为真时，渲染为三个 class，其值根据变量取得



### 绑定内联样式 Style

常用于**组件化开发**时改变组建的样式

*   绑定对象（使用很多）

    与绑定 Class  不同的是：对象的键不是类名，而是属性名，且**属性名称支持 kebab-case 和 camelCase**。值为一个**变量**，**常量需要使用引号包裹**，否则当变量编译时报错。

    ```html
    <!-- style 绑定，size 为变量 -->
    <div :style="{ fontSize: size + 'px' }"></div>
    ```

*   绑定数组

    ```html
    <!-- styleObjectA,styleObjectB 为变量，保存的是对象-->
    <div :style="[styleObjectA, styleObjectB]"></div>
    ```



### 内联字符串拼接

```html
<!-- 内联字符串拼接，fileName为变量 -->
<img :src="'/path/to/images/' + fileName">
```

