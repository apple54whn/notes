# 数据库信息

## 查询数据库信息

```sql
select * from nls_database_parameters
```

| PARAMETER               | VALUE                        |
| ----------------------- | ---------------------------- |
| NLS_RDBMS_VERSION       | 12.2.0.1.0                   |
| NLS_NCHAR_CONV_EXCP     | FALSE                        |
| NLS_LENGTH_SEMANTICS    | BYTE                         |
| NLS_COMP                | BINARY                       |
| NLS_DUAL_CURRENCY       | $                            |
| NLS_TIMESTAMP_TZ_FORMAT | DD-MON-RR HH.MI.SSXFF AM TZR |
| NLS_TIME_TZ_FORMAT      | HH.MI.SSXFF AM TZR           |
| NLS_TIMESTAMP_FORMAT    | DD-MON-RR HH.MI.SSXFF AM     |
| NLS_TIME_FORMAT         | HH.MI.SSXFF AM               |
| NLS_SORT                | BINARY                       |
| NLS_DATE_LANGUAGE       | AMERICAN                     |
| NLS_DATE_FORMAT         | DD-MON-RR                    |
| NLS_CALENDAR            | GREGORIAN                    |
| NLS_NUMERIC_CHARACTERS  | .,                           |
| NLS_NCHAR_CHARACTERSET  | AL16UTF16                    |
| NLS_CHARACTERSET        | AL32UTF8                     |
| NLS_ISO_CURRENCY        | AMERICA                      |
| NLS_CURRENCY            | $                            |
| NLS_TERRITORY           | AMERICA                      |
| NLS_LANGUAGE            | AMERICAN                     |

## 修改编码

可能存在`AL32UTF8`编码的服务器导入中文时字段长度不够问题，需转换为`ZHS16GBK`

```sql
sqlplus /nolog

SQL> conn /as sysdba
SQL> shutdown immediate;
SQL> startup mount;
SQL> ALTER SYSTEM ENABLE RESTRICTED SESSION;
SQL> ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;
SQL> ALTER SYSTEM SET AQ_TM_PROCESSES=0;
SQL> alter database open;
SQL> ALTER DATABASE CHARACTER SET ZHS16GBK;
    ORA-12712: new character set must be a superset of old character set
    --提示我们的字符集：新字符集必须为旧字符集的超集，这时我们可以跳过超集的检查做更改：
SQL> ALTER DATABASE character set INTERNAL_USE ZHS16GBK;
    --我们看到这个过程和之前ALTER DATABASE CHARACTER SET操作的内部过程是完全相同的，也就是说INTERNAL_USE提供的帮助就是使Oracle数据库绕过了子集与超集的校验.
SQL> select * from v$nls_parameters; 
SQL> shutdown immediate;
SQL> startup
SQL> select * from v$nls_parameters;
```





# 备份恢复、常用操作

## sqlplus 登录

如果是docker，在进入容器后需切换oracle用户

```sh
su oracle
```

```SQL
--------------登录前------------------
sqlplus /nolog
conn / as sysdba;
--------------登录前，若报------------------
sqlplus system/oracle@orcl as sysdba;
---------------登录后-----------------
conn system/oracle@orcl as sysdba;
```

查看当前容器（12C有，不懂）

```SQL
show con_name;
=============================
-- 如下为CDB

CON_NAME
------------------------------
CDB$ROOT
```

设置并启动PDB数据库（安装时我的指定名称为orclpdb）（12C有，不懂）

```SQL
alter session set container=orclpdb; 
startup;
```

## 表空间

查看表空间

```sql
select name from v$datafile;
```

查看临时表空间

```sql
select name from v$tempfile;
```

在CDB容器下创建的用户属于公有用户，尽量在PDB容器下创建（安装时指定，我的为orclpdb）（12C有）

```SQL
CREATE TABLESPACE HTDMS3
DATAFILE 'E:\oralce_data\HTDMS33.DBF'
---ubuntu下可以写DATAFILE './HTDMS33.DBF'
---默认会在/u01/app/oracle/product/12.1.0.2/dbhome_1/dbs/htdms3.dbf
SIZE 1024M
AUTOEXTEND ON
NEXT 32M 
MAXSIZE UNLIMITED;
```

## 用户

* 删除原有用户（不删除表空间）

  ```sql
  drop user htdms3 cascade;
  ```
  
  若提示`ORA-01940: 无法删除当前连接的用户`，则需要查看用户的连接状况 
  
  ```sql
  select username,sid,serial# from v$session where username='htdms3';
  -----或-----
  select saddr,sid,serial#,paddr,username,status from v$session where username ='ODI_SRC';
  ```
  
   根据用户的`sid`和`serial`删除
  
  ```sql
  alter system kill session'7,85';
  ```
  
* 创建用户（12c在CDB容器下创建用户需要在前添加C##；PDB容器下不需要）

  ```SQL
  CREATE USER htdms3
  IDENTIFIED BY 111111
  DEFAULT TABLESPACE htdms3;
  ```

* 授权

  ```SQL
  grant all privileges to HTDMS3;
  grant dba to HTDMS3;
  ---------------------------
  grant sysdba to HTDMS3;
  ```

## 备份恢复

* 恢复数据（指定表）

  ```SQL
  imp HTDMS3/111111@192.168.1.108/oradb file=D:/DataBase/bjtrq3/_backup/htdms3.dmp ignore=y FULL=Y
  ```

* 备份数据（指定表）

  owner是当前用户时可以不指定，否则报错
  
  ```sql
exp htdms3/111111@192.168.1.108/oradb file=D:/DataBase/bjtrq3/_backup/HTDMS_1225.dmp log=D:/DataBase/bjtrq3/_backup/HTDMS_1225.log tables=(DMS_GRP_DOC_TYPE) owner=htdms3 
  ```
  
  ```sql
    // 不指定owner如下：
    Connected to: Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production
    Export done in ZHS16GBK character set and AL16UTF16 NCHAR character set
  
    About to export specified users ...
    . exporting pre-schema procedural objects and actions
    . exporting foreign function library names for user DMSZYGD 
    . exporting PUBLIC type synonyms
    . exporting private type synonyms
    . exporting object type definitions for user DMSZYGD 
    About to export DMSZYGD's objects ...
    . exporting database links
    . exporting sequence numbers
    . exporting cluster definitions
    . about to export DMSZYGD's tables via Conventional Path ...
    . . exporting table                    APP_DMS_DOC         86 rows exported
    . . . . . .
    . exporting synonyms
    . exporting views
    . exporting stored procedures
    . exporting operators
    . exporting referential integrity constraints
    . exporting triggers
    . exporting indextypes
    . exporting bitmap, functional and extensible indexes
    . exporting posttables actions
    . exporting materialized views
    . exporting snapshot logs
    . exporting job queues
    . exporting refresh groups and children
    . exporting dimensions
    . exporting post-schema procedural objects and actions
    . exporting statistics
    Export terminated successfully without warnings.
  ```
  
  

  

  



# 数据泵

在Oracle10g中exp imp 被重新设计为Oracle Data Pump（保留了原有的 exp imp工具），数据泵与传统导出导入的区别：

* exp 和 imp 是客户端工具，他们既可以在客户端使用，也可以在服务端使用。　　
* expdp 和impdp 是服务端工具，只能在 Oracle 服务端使用。（不一定，参考下面代码）
* imp 只适用于 exp 导出文件，impdp 只适用于 expdp 导出文件。

如下笔记参考了 https://www.cnblogs.com/chinas/p/8300955.html 

## expdp

1. 为输出路径建立一个数据库的directory对象（`dp_data`需自行填写）

   ```sql
   -- 需在服务器创建该目录
   create or replace directory dp_data as 'D:\app\Administrator\dp_data\';
   ```

   查看是否创建成功

   ```sql
   select * from dba_directories;
   ```

    给将要进行数据导出的用户授权访问 

   ```sql
   grant read,write on directory dp_data to htdms;
   ```

2. 导出

   ```bash
   expdp htdms/bjtrqTXGL2018sc@10.168.52.133/orcl schemas=htdms directory=dp_data dumpfile=htdms3_dp_1128.dmp logfile=htdms3_dp_1128.log
   ```

   * ` full=y `： 全量导出数据库 
   * `tablespace`： 按表空间导出 
   * ` schemas `： 按用户导出 
   * `tables=t1,t2`： 按表导出
   * `tables=table1='where number=1234'`： 按查询条件导   

## impdp

1. 确保数据库directory目录已提前建好（参考expdp）， 提前将源库导出的数据文件传递到目标库的备份目录下 ， 给将要进行数据导入的用户授权访问 

   ```sql
   grant read,write on directory dp_data to htdms3;
   ```

2. 导入

   ```bash
   impdp htdms3/bjtrqTXGL2018sc@10.168.52.133/orcl schemas=htdms REMAP_SCHEMA=htdms:htdms3 REMAP_TABLESPACE=htdms:htdms3 directory=dp_data dumpfile=htdms3_dp_1128.dmp logfile=htdms3_dp_1128.log;
   ```

   * ` full=y `： 全量导入数据库

   * `tablespace`： 按表空间导入，可指定`REMAP_TABLESPACE`

      将表空间TBS01、TBS02、TBS03导入到表空间A_TBS，将用户B的数据导入到A，并生成新的oid防止冲突； 

     ```bash
     impdp A/passwd directory=data_dir dumpfile=expdp.dmp logfile=impdp.log  remap_tablespace=TBS01:A_TBS,TBS02:A_TBS,TBS03:A_TBS remap_schema=B:A FULL=Y transform=oid:n 
     ```

   *  ` schemas `： 按用户导入

     * 若导入的用户名同名，可以不用指定`REMAP_SCHEMA`

     * 否则需要指定映射关系`REMAP_SCHEMA=htdms:htdms3`

   * `tables=t1,t2`： 按表导入

      从A用户中把表table1和table2导入到B用户中

     ```bash
     impdp B/passwd tables=A.table1,A.table2 remap_schema=A:B directory=dp_data dumpfile=expdp.dmp logfile=impdp.log;
     ```

   *  追加数据

     ```bash
     impdp sys/passwd directory=data_dir dumpfile=expdp.dmp schemas=system logfile=impdp.log table_exists_action=replace
     ```

     `table_exists_action`导入对象已存在时执行的操作。可传指：END,REPLACE和TRUNCATE







```sql
impdp htdms3/111111@127.0.0.1/xe SCHEMAS=htdms3 DIRECTORY=bak DUMPFILE=full.dmp LOGFILE=full.log remap_tablespace='htdms':'htdms3'
```









# 恢复某一时间数据

* 查询执行的SQL语句。可以看到SQL_TEXT、LAST_LOAD_TIME

  ```SQL
  select sql_text,last_load_time from v$sql where sql_text like '%update%' order by last_load_time desc;
  ```

* 将数据回滚到需要的时间点

  ```SQL
  alter table $tablename$ enable row movement;
  flashback table $tablename$ to timestamp to_timestamp('xxxx-xx-xx xx:xx:xx', 'yyyy-mm-dd hh24:mi:ss');
  ```






# 修改列类型（已有数据）

```sql
alter table DMS_DOC_REVISION_RECORD add ARC_IDS_TEMP number;
update DMS_DOC_REVISION_RECORD set ARC_IDS_TEMP=ARC_ID,ARC_ID=null;
alter table DMS_DOC_REVISION_RECORD modify ARC_ID VARCHAR2(512);
update DMS_DOC_REVISION_RECORD set ARC_ID=to_char(ARC_IDS_TEMP),ARC_IDS_TEMP=null;
alter table DMS_DOC_REVISION_RECORD drop column ARC_IDS_TEMP;
```





# 北京天然气

## 文件表



## 文件类型表

* **DMS_GRP_DOC_TYPE**

## 制修订流程表

```SQL
-- 文件表
select *
from DMS_DOC 
where ID = 5676;

-- 制修订废止申请表
select *
from DMS_DOC_APPLY t1
where t1.DOC_ID = 5676;

-- 文档修订记录表
select *
from DMS_DOC_REVISION_RECORD 
where DOC_ID = 5676;

-- 审批状态表，根据上一步查询的apply_id
select *
from DMS_DOC_STAGE t1
where t1.APPLY_ID = 10066;

select t1.* 
from APP_PERSON_TASK t1
where t1.SOURCE_ID = 10066;

select *
from APP_PERSON_TASK_OVER t1
where t1.SOURCE_ID = 10066;
```







* **DMS_DOC_APPLY**：制修订废止申请表。

  **#ID = 申请id即 applyId** ，**文件id即 docId即businessId**，申请人id等；**申请状态，审批通过状态**；**最后审批人，意见**，时间等；是否禁用；



* **APP_DMS_DOC**：tablename，文件审批表：

* **APP_DMS_DOC_APPLY**：文件制订申请审批表，字段一模一样

  可根据**business_id 来获取此文件的审批状态等**（多条），审批用户approve_id/name/time/comment意见/通过与否，审批度（？），审批状态（0待审批，1已审批，2无需审批），审批人ip等；

  - 通过approveId **修改** APP_DMS_DOC 表未审批的的审批人id/name/time/comment/isPassed/approve—state/ip

  - （*）获取本审批的审批度和审批级别

  - 通过businessId获取 APP_DMS_DOC 表审批信息，分组（0，1，2）分别几个，计算ONE / MIDDLE / LAST

    - （*）随机审批，，**APP_PERSON_TASK / APP_PERSON_TASK_OVER其他人的审批移动，即待办移已办moveTaskToOver。保存/删除**。APP_DMS_DOC  修改approve_state为2（已审批）

    - 顺序审批，**通过business_id 查询下个人的审批（可能多个）**，修改其审批办理期限等信息（发送时间，截至时间）

      **APP_PERSON_TASK  插入待办任务**

  - **通过 personTaskId 更新审批待办工作表信息APP_PERSON_TASK**，status为1

  - **移动已办工作记录到已办工作表中**，APP_PERSON_TASK / APP_PERSON_TASK_OVER，moveTaskToOver方法，保存/删除

  - 审批不通过

    - **根据businessId 从APP_DMS_DOC查询未审批代办任务信息**，据此通过approveId等从APP_PERSON_TASK获取待办信息，通过待办的id删除该待办（删除所有待办）
    - **通过businessId删除APP_DMS_DOC中没有审批的其他审批信息**

  

  - 审批通过（审批不通过没有此流程）
    - **通过approveId，stageBig=1 修改DMS_DOC_STAGE的OptState为2（已处理）**，ip/time等
    - **根据 approveId 在审批时修改DMS_DOC_STAGE下一个小阶段表**，**OptState为1（正处理）**
      - 根据 approveId 在审批时修改阶段表DMS_DOC_STAGE（状态、时间、ip），修改当前大阶段的下一个审核中小阶段状态（递归方法）

  

* **DMS_DOC_STAGE** ：文件审核阶段表。

  可根据**申请id即 applyId 来获取此申请流程**（多条），**approveId审批id**，分别有大小阶段，该流程操作人的id/name；**操作状态 OPT_STATE（0，1，2）**；操作时间；是否禁用；审批度（？）

  （如何关联？根据personTaskId: 个人审批待办工作ID。但是插入后查询用approve_id。**source_id即businessId查多个**）

* **APP_PERSON_TASK**：审批待办工作表，即待办信息。**审批approveId**，审批用户id/name，状态（0处理中，1已处理），**sourceId（来源编号，待审批业务主键？applyId ）**，moduleId（tablename），审批时间段；

* **APP_PERSON_TASK_OVER**：同上



------

* **DMS_DOC_APPLY**：制修订废止申请表。

  **申请id即 applyId** ，**文件id即 docId即businessId**，申请人id等；**申请状态，审批通过状态**；**最后审批人，意见**，时间等；是否禁用；

* **DMS_DOC_REVISION_RECORD**：文档修订记录表，根据doc_id查询；有**修订文件路径**等

* DMS_DOC_STAGE

* APP_PERSON_TASK

* APP_PERSON_TASK_OVER

















## 意见建议涉及的表

```sql
select t.*, t.rowid from dms_feedback t where t.fb_name = '5.19意见建议' order by t.id desc; --意见建议表
select t.*, t.rowid from dms_feedback_reply t where t.fb_id = '707'  order by t.id desc;--回复信息
select t.*, t.rowid from  dms_comm_adj t where t.table_name = 'DMS_FEEDBACK' order by t.id ; --附件
```

恢复表步骤：

1. 关掉触发器！
2. 备份一张表



DB服务器：（最新的34条左右）

* 20190614：有DMS_FEEDBACK数据的备份，1214条数据
* 20190626：目前能找到最近有DMS_FEEDBACK数据的备份，1228条数据
* 20190724：此时备份DMS_FEEDBACK少数据



DMS_FEEDBACK：

![1565337576361](images/1565337576361.png)



DMS_FEEDBACK_REPLY（但是不一定是丢数据，总量一直没少。6月14号1581条，7月24号1613条）：

![1565337654962](images/1565337654962.png)

![1565337813525](images/1565337813525.png)

结论：

* 6月14号有备份



## 权限表

SYS_PERMS_RES



## 统计融合文件

```SQL
select t1.ID,t1.DOC_ID,t1.APPLY_DOC_NAME,t4.CREATE_UNIT_NAME,t4.CREATE_USER_NAME,t1.CREATE_USER_NAME modify_user_name,t5.OPT_USER_NAME,t5.STAGE_NAME
from DMS_DOC_APPLY t1
left join APP_PERSON_TASK t3 on t1.ID =t3.SOURCE_ID
left join DMS_DOC t4 on t1.DOC_ID = t4.ID
left join DMS_DOC_STAGE t5 on t3.APPROVE_ID = t5.APPROVE_ID
where t1.DOC_TYPE_ID in (2, 47, 235)
  and t1.IS_DISABLED = 0
  and t1.APPLY_TYPE = 2
  and t1.CREATE_TIME >= TO_DATE('2019-08-26 00:00:00', 'yyyy-MM-dd HH24:MI:SS');
```

## 手动将流程中修订改为融合文件

```SQL
--1 查找制修订申请 --id：10135
select  t.LAST_APP_USER_NAME,t.* from dms_doc_apply t where t.apply_doc_name like '%记录与资料管理程序%' order by ID desc ;
--select t.*, t.rowid from dms_doc_main_file t where t.file_name like '%党风廉政建设管理办法%';

-- 根据最后审批id，下载文件
select t.* from sys_user t where t.name like '%刘银忠%';


--2 查找文件，并复制，修改apply_id（即1步骤中的id）  --id：9064
select t.id,t.apply_id,t.* from dms_doc t where t.doc_name like '%记录与资料管理程序%' order by t.ID desc ;

insert into dms_doc ( doc_number, doc_name, doc_abstract, doc_keyword, exe_date, owner_id, owner_name, participate_unit_list, public_time, applied_scope, doc_url, doc_size, doc_suffix, parent_grp_doc_type_id, grp_doc_type_id, grp_mgmt_field_id, grp_biz_act_id, parent_grp_owner_depart_id, grp_owner_depart_id, create_user_id, create_user_name, create_unit_id, create_unit_name, create_depart_id, create_depart_name, create_time, doc_stage, is_easy, is_test_run, trial_run, over_test_run_time, doc_no, curr_version, apply_id, is_disabled, ip_addr, old_id, old_doc_number, type_depart_id, content) select t.doc_number, t.doc_name, t.doc_abstract, t.doc_keyword, t.exe_date, t.owner_id, t.owner_name, t.participate_unit_list, t.public_time, t.applied_scope, t.doc_url, t.doc_size, t.doc_suffix, t.parent_grp_doc_type_id, t.grp_doc_type_id, t.grp_mgmt_field_id, t.grp_biz_act_id, t.parent_grp_owner_depart_id, t.grp_owner_depart_id, t.create_user_id, t.create_user_name, t.create_unit_id, t.create_unit_name, t.create_depart_id, t.create_depart_name, t.create_time, '3', t.is_easy, t.is_test_run, t.trial_run, t.over_test_run_time, t.doc_no, t.curr_version, t.apply_id, t.is_disabled, t.ip_addr, t.old_id, t.old_doc_number, t.type_depart_id, t.content from dms_doc t
where t.id = '5736' ; --id即为要复制的id

--4 流程中的文件，需修改dms_doc_revision_record表的doc_id，2步骤中新加的id即可
select  t.*
  from dms_doc_revision_record t
 where t.file_name like '%记录与资料管理程序%'
--  and t.doc_id = '9007'
 order by t.create_time desc;  --文档修订记录表


--5删除代办 --userid改为1，source_id即为审批id 即步骤1中的id
select t.* from app_person_task t where t.source_id = '10135';
update APP_PERSON_TASK set APPROVE_USER_ID = 1 where SOURCE_ID = '10135';
```



## 用户表等

ptr账户未录入（表中数据还有问题！）

```SQL
select t1.NAME, t1.USERNAME, t1.ID, t3.UNIT_NAME,t4.DEPART_SHORT_NAME
from SYS_USER t1
         left join SYS_USER_3RD_ACCOUNT t2 on t1.ID = t2.USER_ID
         left join SYS_USER_DEPART t3 on t1.ID = t3.USER_ID
         left join SYS_DEPART t4 on t3.DEPART_ID = t4.ID
where t2.PTR is null
  and t1.IS_DISABLED = 0
  and t2.IS_DISABLED = 0;
```



## 修订时文件编号

* 提交后
  * 修改 DMS_DOC_APPLY 的 DOC_NUMBER 
  * 将 DMS_DOC 的 DOC_NUMBER 存入 OLD_DOC_NUMBER
  * 修改 DMS_DOC  的 DOC_NO ？？？
* 发布时
  * 修改 DMS_DOC 的 CurrVersion 和 DocNumber

# 中油管道

 

内控工作管理程序

审计工作管理程序，内部审计工作管理程序	